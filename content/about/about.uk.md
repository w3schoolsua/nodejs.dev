---
title: about
displayTitle: About
description: 'About | Node.js'
authors: XhmikosR, mikeal, fhemberger, Fishrock123, yous, tomgco, tniessen, SMcCandlish, saadq, Trott, Gornstats, piperchester, naoufal,  lpinca, j9t, bnoordhuis, harshadsabne, Chris911, benhalverson
category: about
---

Як асинхронне середовище виконання JavaScript, кероване подіями, 
Node.js розроблено для створення масштабованих мережевих програм. 
У наведеному нижче прикладі "Hello World" багато підключень можна обробляти одночасно. 
Після кожного підключення запускається зворотний виклик, 
але якщо роботи не потрібно виконувати, Node.js буде спати.

```js
const http = require('http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World');
});

server.listen(port, hostname, () => {
  // eslint-disable-next-line no-console
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Це на відміну від сьогоднішньої більш поширеної моделі паралелізму, 
в якій використовуються потоки ОС. Мережа на основі потоків відносно 
неефективна і дуже складна у використанні. Крім того, користувачі Node.js 
не хвилюються про блокування процесу, оскільки блокувань немає. 
Майже жодна функція в Node.js безпосередньо не виконує введення-виведення, 
тому процес ніколи не блокується, за винятком випадків, коли введення-виведення 
виконується за допомогою синхронних методів стандартної бібліотеки Node.js. 
Оскільки ніщо не блокує, масштабовані системи дуже розумно розробляти на Node.js.

Якщо частина цієї мови незнайома, є повна стаття
[Blocking vs. Non-Blocking][].

***

Node.js подібний за дизайном до таких систем, як Ruby, і на них впливають
[Event Machine][] і Python [Twisted][]. Node.js розвиває модель подій трохи далі. 
Він представляє цикл подій як конструкцію часу виконання, а не як бібліотеку. 
В інших системах завжди існує блокуючий виклик для запуску циклу подій. 
Як правило, поведінка визначається через зворотні виклики на початку сценарію, 
а в кінці сервер запускається через блокуючий виклик, як-от EventMachine::run()`. 
У Node.js немає такого виклику запуску циклу подій. Node.js просто входить 
у цикл подій після виконання вхідного сценарію. Node.js виходить із циклу подій, 
коли більше немає зворотних викликів для виконання. Така поведінка схожа на 
JavaScript у браузері — цикл подій прихований від користувача.

HTTP є першокласним громадянином у Node.js, розробленому з урахуванням потокового 
передавання та низької затримки. Це робить Node.js добре придатним для створення веб-бібліотеки або фреймворку.

Оскільки Node.js розроблено без потоків, це не означає, що ви не можете взяти
перевага кількох ядер у вашому середовищі. Дочірні процеси можуть бути породжені 
за допомогою нашого [`child_process.fork()`][] API, і розроблені для зручності спілкування. 
На цьому ж інтерфейсі побудований модуль [`cluster`][], який дозволяє вам спільно 
використовувати сокети між процесами, щоб забезпечити балансування навантаження на ваші ядра.

[blocking vs. non-blocking]: /learn/overview-of-blocking-vs-non-blocking/
[`child_process.fork()`]: /api/child_process/
[`cluster`]: https://nodejs.org/api/cluster.html
[event machine]: https://github.com/eventmachine/eventmachine
[twisted]: https://twistedmatrix.com/trac/
